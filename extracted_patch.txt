SimuVaction War Room
Patch and Expansion Specification (v2.1)
Delta document to be applied on top of “Complete Technical Specification v2.0”
Audience: Implementation agent(s) already building the app
Scope: Close functional gaps, harden security (RLS), finalize chat/votes/news approvals/notifications, and upgrade UI/UX
This document avoids repeating v2.0; it references v2.0 sections when needed and adds missing details, concrete migrations, policies, and code patterns.
Table of Contents
Note: In Word, right-click this page and choose “Update Field” if you add an automatic TOC later.
1. Executive delta summary
2. Architecture updates (v2.1)
3. Multi-tenancy redesign: users vs event memberships
4. Security model: RBAC + RLS rewrite (no data leaks)
5. Chat v2.1: membership-based private rooms + unread counts + moderation
6. Notifications v2.1: in-app + push + scheduling + device tokens
7. Voting v2.1: public/secret + per-person/per-delegation + quorum + roll-call + audit
8. Newsroom & Press Room v2.1: approval workflow (2 journalists + 1 leader)
9. PWA & mobile delivery: iOS constraints, offline strategy, push setup
10. AI Copilot safety envelope + skills registry
11. UI/UX upgrade plan: design tokens, layouts, map interactions, accessibility
12. API surface refinements: endpoints, auth guards, rate limits
13. Ops, cron, backups, export/archival, observability
14. Migration plan: steps, rollbacks, data backfill
15. Acceptance tests & QA scenarios
16. References (primary sources)
1. Executive delta summary
Spec v2.0 is a strong baseline, but several parts are under-specified or inconsistent in ways that will cause either (a) data leakage (RLS too permissive), (b) features that cannot work (private chat rooms without membership), or (c) “demo-only” integrations (push notifications without device token model and OAuth authorization).
1.1 What must change immediately (non-negotiable)
Replace single-event users table design with an event_memberships model so one account can join multiple years/events cleanly.
Rewrite RLS policies so that: users can only read what their role + memberships allow; leaders cannot read private rooms; admins can.
Add chat_memberships to support unlimited private rooms with explicit invite lists and accurate authorization.
Add notifications + device token tables; rework push sending to use trusted server-side OAuth for FCM HTTP v1.
Replace simplistic voting JSONB options with a normalized model that supports per-person/per-delegation ballots, secret/public, and roll-call.
1.2 Sources driving the delta decisions (why this is not optional)
Supabase Realtime has explicit project limits (connections, messages/sec, payload sizes) that influence chat and notifications design. Additionally, Supabase Postgres Changes authorizes every change for every subscriber, creating scalability patterns that must be planned.
Realtime limits by plan (connections, messages/sec, payload sizes).
Postgres Changes scaling: each insert can trigger one authorization read per subscriber; single-thread processing order.
FCM HTTP v1 requires OAuth 2.0 access tokens and must be sent from a trusted server environment.
iOS Web Push works for Home Screen web apps (PWA) and requires user interaction for permission prompts.
Vercel cron runs only on production deployments; Vercel invokes your endpoint via HTTP GET; cron user agent can be used for filtering.
2. Architecture updates (v2.1)
This section is a surgical update to v2.0 Sections 2–4 (Architecture, Stack, Directory Structure). The stack remains Next.js (App Router) + Supabase (Postgres + Auth + Realtime + Storage) + Vercel. The delta is primarily the data model, RLS approach, and realtime primitives used for chat and notifications.
2.1 Revised high-level architecture diagram
+-----------------------+      +---------------------------+      +----------------------+
| Next.js App (Vercel)  |      | Supabase (Postgres/Auth)  |      | External services    |
| - App Router          |<---->| - RLS enforced APIs       |<---->| - Firebase (FCM)     |
| - Middleware auth     |  WS  | - Realtime (Broadcast)    |  HTTPS| - Map tiles provider |
| - Server Actions/API  |      | - Storage (files)         |      | - Email/SMTP (opt)   |
+----------+------------+      +------------+--------------+      +----------+-----------+
           |                                |                            |
           | PWA (Service Worker)           |                            |
           v                                v                            v
+-----------------------+      +---------------------------+      +----------------------+
| Client devices        |      | Edge / Cron endpoints     |      | Push delivery        |
| - Mobile (PWA)        |      | - Close votes             |      | - iOS/Android/Web    |
| - Desktop browser     |      | - Send reminders          |      | - OS notification UI |
+-----------------------+      +---------------------------+      +----------------------+
2.2 Realtime strategy (Broadcast-first)
For chat and notifications, prefer Supabase Realtime Broadcast channels for low-latency delivery and to avoid Postgres Change fanout where possible. Use Postgres for persistence and unread counts, but do not rely on Postgres Changes as the primary transport at scale (even 60–80 users can produce noticeable fanout during spikes).
Reason: Supabase notes that Postgres Changes authorization is done per subscriber and processed on a single thread to preserve order, so high write rates can create bottlenecks. Use Broadcast for “fast lane” and Postgres as the source of truth.
2.3 Plan constraints and rate budgets
Design for Pro plan limits as a baseline: 500 concurrent connections, 500 messages/sec, and broadcast payload size up to 3,000 KB (per Supabase docs). Your app should still behave under Free plan limits during development.
3. Multi-tenancy redesign: users vs event memberships
v2.0 stores event_id on the users table. This blocks the same account from participating across years (2026, 2027, etc.) and makes role changes awkward. Fix: convert to global user profiles + per-event memberships.
3.1 Target data model
3.1.1 Global user profile
-- Profiles: stable across years
create table public.user_profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  display_name text not null,
  avatar_url text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index on public.user_profiles (email);
3.1.2 Event membership (the real RBAC)
-- One row per user per event (year)
create table public.event_memberships (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  role text not null check (role in ('delegate','journalist','lobbyist','leader','admin')),
  team_id uuid null references public.teams(id) on delete set null,
  status text not null default 'active' check (status in ('active','suspended','archived')),
  joined_at timestamptz default now(),
  unique (event_id, user_id)
);
create index on public.event_memberships (event_id, role);
create index on public.event_memberships (event_id, team_id);
3.2 Current-event selection in app session
Recommendation: let users switch current event from a dropdown (top-left) if they belong to multiple events. Store current event id in a secure, httpOnly cookie (server-set) or in a dedicated table event_last_selected (per user). RLS should not trust client-provided event_id.
3.3 Why not store role in user_metadata
Supabase warns that user-editable metadata should not be used for authorization decisions; store role/membership in database tables or in auth app_metadata controlled server-side. Use auth.uid() to identify requester and join against membership tables.
4. Security model: RBAC + RLS rewrite (no data leaks)
This section replaces v2.0 Section 6 with a corrected RLS model. The guiding principle: Policies act like implicit WHERE clauses; keep them simple, testable, and based on trusted membership tables.
4.1 Canonical helper functions (SECURITY DEFINER)
-- Returns current authenticated user id
create or replace function public.uid()
returns uuid language sql stable as $$
  select auth.uid();
$$;
-- Check if user is admin (event-scoped)
create or replace function public.is_event_admin(p_event uuid)
returns boolean language sql stable security definer as $$
  select exists (
    select 1 from public.event_memberships m
    where m.event_id = p_event and m.user_id = auth.uid() and m.role = 'admin'
  );
$$;
-- Check if user is leader or admin (event-scoped)
create or replace function public.is_event_leader(p_event uuid)
returns boolean language sql stable security definer as $$
  select exists (
    select 1 from public.event_memberships m
    where m.event_id = p_event and m.user_id = auth.uid()
      and m.role in ('leader','admin')
  );
$$;
-- Return user's membership row for an event (null if not member)
create or replace function public.my_membership(p_event uuid)
returns public.event_memberships language sql stable security definer as $$
  select * from public.event_memberships
  where event_id = p_event and user_id = auth.uid()
  limit 1;
$$;
4.2 RLS core pattern
Every row is scoped by event_id. Access is granted by existence of a corresponding event_memberships row, plus any feature-specific membership tables (chat_memberships, vote_eligibility, etc.).
4.2.1 Events: read access
alter table public.events enable row level security;
create policy "members can read their events"
on public.events for select
to authenticated
using (
  exists (
    select 1 from public.event_memberships m
    where m.event_id = id and m.user_id = auth.uid()
  )
);
create policy "admins can manage events"
on public.events for all
to authenticated
using ( public.is_event_admin(id) )
with check ( public.is_event_admin(id) );
4.2.2 Profiles: read your own profile, limited directory
Instead of letting everyone read all user profiles, we implement a directory view via a view or RPC that exposes only safe fields.
alter table public.user_profiles enable row level security;
create policy "users read own profile"
on public.user_profiles for select
to authenticated
using ( id = auth.uid() );
create policy "users update own profile"
on public.user_profiles for update
to authenticated
using ( id = auth.uid() )
with check ( id = auth.uid() );
4.2.3 Directory view (safe fields only)
-- A view that joins membership to show display_name + avatar + role + team for current event
create or replace view public.event_directory as
select
  m.event_id,
  p.id as user_id,
  p.display_name,
  p.avatar_url,
  m.role,
  m.team_id
from public.event_memberships m
join public.user_profiles p on p.id = m.user_id;
-- RLS on views: enforce through security_invoker / RLS on underlying tables and a policy on event_memberships.
4.3 Anti-patterns to avoid (explicitly)
Do not grant user listing by event with a blanket policy like (event_id = current_event_id()).
Do not rely on user_metadata for role checks; it can be user-editable. Prefer database tables or auth app_metadata (server-set).
Avoid complex RLS policies with multiple joins inside frequently hit tables (chat_messages). Prefer membership checks with indexed keys.
5. Chat v2.1: membership-based private rooms + unread counts + moderation
v2.0 chat has chat_channels and chat_messages, with is_private and allowed_roles, but no explicit membership list. Your product requirement is unlimited private rooms per team, leaders cannot enter private rooms, and admin can enter anywhere. Therefore we need chat_memberships and room types.
5.1 Data model (replace chat_channels)
create table public.chat_rooms (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  name text not null,
  room_type text not null check (room_type in ('global','team','private')),
  team_id uuid null references public.teams(id) on delete set null,
  created_by uuid not null references public.user_profiles(id) on delete set null,
  created_at timestamptz default now()
);
create index on public.chat_rooms (event_id, room_type);
create index on public.chat_rooms (event_id, team_id);
create table public.chat_memberships (
  room_id uuid not null references public.chat_rooms(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  role text not null default 'member' check (role in ('owner','moderator','member')),
  joined_at timestamptz default now(),
  primary key (room_id, user_id)
);
create index on public.chat_memberships (user_id);
create table public.chat_messages (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  room_id uuid not null references public.chat_rooms(id) on delete cascade,
  sender_id uuid not null references public.user_profiles(id) on delete set null,
  body text not null,
  created_at timestamptz default now(),
  edited_at timestamptz,
  deleted_at timestamptz,
  reply_to uuid references public.chat_messages(id)
);
create index on public.chat_messages (room_id, created_at);
5.2 Unread counts model
-- Track last read per room per user
create table public.chat_reads (
  room_id uuid not null references public.chat_rooms(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  last_read_at timestamptz not null default now(),
  primary key (room_id, user_id)
);
5.3 RLS policies (leaders excluded from private rooms)
alter table public.chat_rooms enable row level security;
alter table public.chat_memberships enable row level security;
alter table public.chat_messages enable row level security;
alter table public.chat_reads enable row level security;
-- Rooms: read if global room + member of event, OR you are in chat_memberships, OR you are event admin.
create policy "read chat rooms"
on public.chat_rooms for select
to authenticated
using (
  exists(select 1 from public.event_memberships m where m.event_id = event_id and m.user_id = auth.uid())
  and (
    room_type = 'global'
    or exists(select 1 from public.chat_memberships cm where cm.room_id = id and cm.user_id = auth.uid())
    or public.is_event_admin(event_id)
  )
);
-- Membership: users can see membership rows only for rooms they can read.
create policy "read chat memberships"
on public.chat_memberships for select
to authenticated
using (
  exists(
    select 1 from public.chat_rooms r
    where r.id = room_id
      and (
        r.room_type = 'global'
        or exists(select 1 from public.chat_memberships cm where cm.room_id = r.id and cm.user_id = auth.uid())
        or public.is_event_admin(r.event_id)
      )
  )
);
-- Messages: read if room readable
create policy "read chat messages"
on public.chat_messages for select
to authenticated
using (
  exists(select 1 from public.chat_rooms r
    where r.id = room_id
      and r.event_id = chat_messages.event_id
      and (
        r.room_type = 'global'
        or exists(select 1 from public.chat_memberships cm where cm.room_id = r.id and cm.user_id = auth.uid())
        or public.is_event_admin(r.event_id)
      )
  )
);
-- Insert: user must be a member of room OR room is global; must be member of event
create policy "send chat messages"
on public.chat_messages for insert
to authenticated
with check (
  sender_id = auth.uid()
  and exists(select 1 from public.event_memberships m where m.event_id = event_id and m.user_id = auth.uid())
  and exists(select 1 from public.chat_rooms r
    where r.id = room_id and r.event_id = event_id
      and (
        r.room_type = 'global'
        or exists(select 1 from public.chat_memberships cm where cm.room_id = r.id and cm.user_id = auth.uid())
        or public.is_event_admin(r.event_id)
      )
  )
);
5.4 Realtime implementation details
Use Broadcast channels for each room: `room:{room_id}`. Persist all messages to Postgres; broadcast lightweight payloads (message id, sender id, created_at, truncated body) to stay under broadcast payload limits.
Supabase Realtime plan limits include concurrent connections, messages/sec, and payload size; design with backpressure and rate limiting (slow mode in global chat, anti-spam).
6. Notifications v2.1: in-app + push + scheduling + device tokens
v2.0 references FCM token in users table and a send-notification edge function, but there is no device token model and no in-app notification store. v2.1 adds both, and formalizes which events trigger push vs in-app.
6.1 Data model
create table public.notifications (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  type text not null, -- vote_opened, vote_closed, mention, meeting_request, deadline_reminder, news_published, etc
  title text not null,
  body text not null,
  deep_link text, -- /events/{id}/votes/{poll_id}
  priority text not null default 'normal' check (priority in ('low','normal','high','urgent')),
  created_at timestamptz default now(),
  read_at timestamptz
);
create index on public.notifications (user_id, created_at desc);
create index on public.notifications (event_id, user_id);
create table public.user_device_tokens (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  platform text not null check (platform in ('web','ios','android')),
  token text not null,
  created_at timestamptz default now(),
  last_seen_at timestamptz default now(),
  unique (user_id, token)
);
6.2 Push delivery: trusted server only
Firebase FCM HTTP v1 requires OAuth 2.0 access tokens and must be sent from a trusted server environment; sending from client logic is not supported. Use a server function (Vercel/Edge) or Supabase Edge Function to mint access tokens using a service account and call FCM send endpoint.
6.3 iOS constraints (PWA only)
On iOS/iPadOS, web push notifications are supported for Home Screen web apps (installed PWAs). Permission prompts must happen in response to a user gesture (tap). Build UX: show an explicit “Enable notifications” button and explain “Install the app to receive push on iPhone.”
7. Voting v2.1: public/secret + per-person/per-delegation + quorum + roll-call + audit
v2.0 voting uses voting_polls with JSONB options and voting_responses unique by (poll_id, user_id). This cannot enforce per-delegation votes and cannot support robust secret/public modes without leaks. v2.1 normalizes voting options and adds eligibility + audit structures.
7.1 Data model
create table public.votes (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  created_by uuid not null references public.user_profiles(id),
  title text not null,
  description text,
  ballot_mode text not null check (ballot_mode in ('per_person','per_delegation')),
  visibility text not null check (visibility in ('public','secret')),
  show_live_results boolean not null default false,
  quorum_percent int not null default 0 check (quorum_percent between 0 and 100),
  open_at timestamptz,
  close_at timestamptz,
  status text not null default 'draft' check (status in ('draft','open','closed','cancelled')),
  created_at timestamptz default now()
);
create index on public.votes (event_id, status, close_at);
create table public.vote_options (
  id uuid primary key default gen_random_uuid(),
  vote_id uuid not null references public.votes(id) on delete cascade,
  option_key text not null, -- yes/no/abstain, or custom
  label text not null,
  sort_order int not null default 0,
  unique (vote_id, option_key)
);
-- eligibility: either by role, by team, or explicit users
create table public.vote_eligibility_roles (
  vote_id uuid not null references public.votes(id) on delete cascade,
  role text not null,
  primary key (vote_id, role)
);
create table public.vote_eligibility_teams (
  vote_id uuid not null references public.votes(id) on delete cascade,
  team_id uuid not null references public.teams(id) on delete cascade,
  primary key (vote_id, team_id)
);
-- ballots: store "who participated" separately from "how they voted" for secret mode
create table public.vote_ballots (
  id uuid primary key default gen_random_uuid(),
  vote_id uuid not null references public.votes(id) on delete cascade,
  event_id uuid not null references public.events(id) on delete cascade,
  voter_user_id uuid null references public.user_profiles(id), -- null if secret+anonymized
  voter_team_id uuid null references public.teams(id),
  cast_at timestamptz default now(),
  unique (vote_id, voter_user_id)
);
create table public.vote_casts (
  ballot_id uuid not null references public.vote_ballots(id) on delete cascade,
  option_id uuid not null references public.vote_options(id) on delete cascade,
  primary key (ballot_id)
);
-- optional: roll-call log (public mode)
create table public.vote_rollcall (
  vote_id uuid not null references public.votes(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id),
  option_key text not null,
  cast_at timestamptz default now(),
  primary key (vote_id, user_id)
);
-- audit log (leaders/admin only)
create table public.audit_log (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  actor_id uuid references public.user_profiles(id),
  action text not null,
  entity_type text not null,
  entity_id uuid,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz default now()
);
create index on public.audit_log (event_id, created_at desc);
7.2 Quorum and tally RPC
Implement tally as a SECURITY DEFINER function returning aggregated counts. This avoids exposing per-ballot rows in secret mode. Results visibility rules are applied in the RPC.
create or replace function public.tally_vote(p_vote uuid)
returns table(option_key text, count bigint, total bigint, met_quorum boolean)
language plpgsql security definer as $$
declare
  v_event uuid;
  v_quorum int;
  v_total bigint;
  v_casted bigint;
begin
  select event_id, quorum_percent into v_event, v_quorum from public.votes where id = p_vote;
  -- Only event leader/admin can tally secret votes while open; public votes can expose live if configured.
  -- (Additional checks can be enforced here.)
  select count(*) into v_total
  from public.event_memberships m
  where m.event_id = v_event
    and exists (select 1 from public.vote_eligibility_roles r where r.vote_id = p_vote and r.role = m.role);
  select count(*) into v_casted
  from public.vote_ballots b
  where b.vote_id = p_vote;
  return query
  select o.option_key,
         count(c.option_id) as count,
         v_total as total,
         (case when v_total = 0 then true else (v_casted * 100 / v_total) >= v_quorum end) as met_quorum
  from public.vote_options o
  left join public.vote_casts c on c.option_id = o.id
  left join public.vote_ballots b on b.id = c.ballot_id and b.vote_id = p_vote
  where o.vote_id = p_vote
  group by o.option_key, v_total, v_casted, v_quorum;
end;
$$;
8. Newsroom & Press Room v2.1: approval workflow (2 journalists + 1 leader)
v2.0 stores approved_by as UUID[] on news_posts, but it cannot enforce the rule ‘2 journalists + 1 leader’ reliably and lacks auditability. v2.1 introduces a normalized approvals table and a publish gate function.
8.1 Data model
create table public.news_posts (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  author_id uuid not null references public.user_profiles(id) on delete set null,
  title text not null,
  body text not null,
  status text not null default 'draft' check (status in ('draft','submitted','published','rejected')),
  published_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index on public.news_posts (event_id, status, created_at desc);
create table public.news_approvals (
  post_id uuid not null references public.news_posts(id) on delete cascade,
  approver_id uuid not null references public.user_profiles(id) on delete cascade,
  approver_role text not null check (approver_role in ('journalist','leader','admin')),
  decision text not null check (decision in ('approve','reject')),
  reason text,
  decided_at timestamptz default now(),
  primary key (post_id, approver_id)
);
create index on public.news_approvals (post_id, approver_role, decision);
8.2 Publish gate function
create or replace function public.can_publish_news(p_post uuid)
returns boolean
language plpgsql security definer as $$
declare v_event uuid;
declare j_count int;
declare l_count int;
begin
  select event_id into v_event from public.news_posts where id = p_post;
  select count(*) into j_count
  from public.news_approvals a
  join public.event_memberships m on m.user_id = a.approver_id and m.event_id = v_event
  where a.post_id = p_post and a.decision = 'approve' and m.role = 'journalist';
  select count(*) into l_count
  from public.news_approvals a
  join public.event_memberships m on m.user_id = a.approver_id and m.event_id = v_event
  where a.post_id = p_post and a.decision = 'approve' and m.role in ('leader','admin');
  return j_count >= 2 and l_count >= 1;
end;
$$;
9. PWA & mobile delivery: iOS constraints, offline strategy, push setup
The product wants “downloadable app”. The fastest path is PWA with Add to Home Screen; later you can wrap with Capacitor/Expo if needed. iOS push requires Home Screen web app mode and user interaction for permission prompts.
9.1 Manifest requirements
// public/manifest.webmanifest (minimal)
{
  "name": "SimuVaction War Room",
  "short_name": "War Room",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0b0f1a",
  "theme_color": "#0b0f1a",
  "icons": [
    { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
9.2 Push permission UX
Add a dedicated screen: Settings > Notifications. On iOS, show a banner: “Install War Room to enable push on iPhone/iPad.” Offer an Install CTA and detect standalone mode.
export function isStandalonePwa(): boolean {
  // iOS: navigator.standalone; modern: display-mode
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const nav: any = navigator;
  return window.matchMedia?.('(display-mode: standalone)').matches || !!nav.standalone;
}
10. AI Copilot safety envelope + skills registry
The AI copilot must accelerate writing without creating security holes. The key risks are prompt injection, data exfiltration, and unauthorized context access. v2.1 defines a skills registry, strict scoping rules, and audit logging.
10.1 Skills registry table
create table public.ai_skills (
  key text primary key, -- 'rewrite_diplomatic', 'summarize', 'amendment_suggestions'
  description text not null,
  allowed_roles text[] not null,
  max_input_chars int not null default 12000,
  max_output_chars int not null default 6000,
  enabled boolean not null default true
);
10.2 AI requests log (for observability and abuse control)
create table public.ai_requests (
  id uuid primary key default gen_random_uuid(),
  event_id uuid not null references public.events(id) on delete cascade,
  user_id uuid not null references public.user_profiles(id) on delete cascade,
  skill_key text not null references public.ai_skills(key),
  doc_ref text, -- pointer to doc/entity in your DB
  input_hash text not null,
  tokens_in int,
  tokens_out int,
  created_at timestamptz default now()
);
10.3 Scope rule
Copilot can only read the current editor document + explicitly selected references (no global search by default).
Copilot never publishes automatically; it only proposes edits in a review UI.
All copilot actions create audit_log entries (skill invoked, target doc, user id).
11. UI/UX upgrade plan: design tokens, layouts, map interactions, accessibility
Your current V1 prototype is strong. v2.1 focuses on polishing, consistency, and speed of comprehension. Use shadcn/ui as the base component system. It supports fast installation and consistent component patterns.
11.1 Design tokens (recommended defaults)
Typography: Inter (or system font) with Calibri fallback; scale: 12/14/16/20/24/32.
Radius: 12px for cards, 10px for inputs, 9999px for pills.
Spacing: 4/8/12/16/24/32.
Color: dark-first theme; neutral base; single accent color per event (optional).
Shadows: subtle 1-2 levels only; prioritize legibility.
11.2 Page templates to standardize
Situation Room (public): full map canvas + right rail (news) + bottom strip (deadlines) + top nav.
Country Card (modal / side sheet): delegates, stance, priorities, contact buttons, recent posts.
Workspace (private): left nav (pillars), main content, right rail (tasks, meetings, votes).
Chat: two-pane (rooms list + messages) with mobile bottom-nav switcher.
Votes: list view + detail view (ballot) + results panel with quorum indicator.
11.3 Map interactions
Use MapLibre’s HTML cluster patterns for interactive markers and clusters. Ensure country cards open from marker click, and clusters expand on click.
12. API surface refinements: endpoints, auth guards, rate limits
v2.0 lists endpoints, but enforcement must be aligned with the new membership model. Prefer: (a) direct Supabase queries from client for simple reads, protected by RLS; (b) server routes only for privileged actions (publish news, close votes, send push).
12.1 Protect cron endpoints
Vercel invokes cron jobs only for production deployments. Also, Vercel triggers cron by making an HTTP GET request to your endpoint; treat cron endpoints as public unless you enforce a shared secret header or token.
12.2 Rate limiting
Global chat: enforce 1 message per user per N seconds (N=2–5).
News submissions: max 10/day per user (tunable).
Votes: prevent repeated casts via unique constraints and RLS.
AI copilot: per-user token quota with daily reset.
13. Ops, cron, backups, export/archival, observability
This section expands v2.0 Deployment Guide into an operations playbook. Key objective: predictable behavior during the event week, and easy export/archival at the end.
13.1 Cron jobs (production-only)
Vercel cron jobs run only on production deployments (not preview). Use this for closing expired votes and sending deadline reminders.
13.2 Export and archive
End of edition: export event data as JSON + CSV (votes/results, news posts, chat transcripts).
Freeze mode: set event.status='archived' and enforce read-only RLS for non-admins.
Store exports in object storage and optionally download to offline drive.
13.3 Observability
Audit log: all privileged actions (vote created/closed, news published, moderation) recorded.
Realtime monitoring: track join rate, messages/sec; throttle if approaching plan limits.
Error tracking: Sentry or equivalent; include user_id and event_id tags.
14. Migration plan: steps, rollbacks, data backfill
Create new tables: user_profiles, event_memberships, chat_rooms, chat_memberships, notifications, user_device_tokens, votes, vote_options, news_approvals, audit_log.
Backfill: copy existing users rows into user_profiles; create event_memberships rows per user/event; map roles.
Map old chat_channels to chat_rooms: create one global room per event; create team rooms per team; migrate messages; create chat_memberships for participants.
Deploy new RLS policies: enable RLS on new tables; remove permissive policies that grant event-wide access to user rows.
Update app queries: switch role/team checks to event_memberships; replace channel_id with room_id everywhere; adjust vote and newsroom modules.
Soft launch: run in parallel for 24h with a test event and 10 test users; verify leaders cannot access private rooms and that secret votes cannot be deanonymized through direct selects.
Hard cutover: disable writes to old tables; archive old tables; finalize migration notes in /docs.
15. Acceptance tests & QA scenarios
15.1 Security tests (RLS)
Delegate cannot read private room messages unless invited.
Leader cannot read private room messages even if they guess room id.
Admin can join any room and view messages.
User in event A cannot read any data for event B.
Secret vote: non-admin cannot reconstruct who voted what from database reads or RPCs.
News approvals: only eligible roles can approve; final publish allowed only when approvals satisfy rule.
15.2 Functional tests
Create a private room with 3 members; messages deliver realtime and persist after refresh.
Unread counts update when receiving messages; clearing on open works; background updates do not cause infinite re-render loops.
Vote created, opened, quorum met, closed; tally returns correct result; roll-call displays in public mode only.
News submission drafted by delegate; approvals by 2 journalists + 1 leader; then published and appears on public newsroom feed.
Notifications appear in-app; push works when PWA installed and user enabled it; fallback to in-app when push not available.
15.3 Load tests (event week)
Simulate 80 users online; ensure connections under plan limit and no too_many_connections errors.
Simulate chat spike: 100 messages/min in global; ensure rate limiting keeps within messages/sec limits.
Simulate vote close cron every 5 minutes; ensure idempotent closure to avoid duplicate audit logs.
16. References (primary sources)
Supabase
Row Level Security guide: https://supabase.com/docs/guides/database/postgres/row-level-security
Realtime limits: https://supabase.com/docs/guides/realtime/rate-limits
Realtime Postgres Changes limitations and scaling notes: https://supabase.com/docs/guides/realtime/postgres-changes
Firebase
FCM HTTP v1 auth (server-side OAuth token): https://firebase.google.com/docs/cloud-messaging/auth-server
Migrate to HTTP v1 (authorization update notes): https://firebase.google.com/docs/cloud-messaging/migrate-v1
Apple / WebKit
Web Push for Web Apps on iOS and iPadOS (Home Screen apps, iOS 16.4+): https://webkit.org/blog/13878/web-push-for-web-apps-on-ios-and-ipados/
Vercel
Cron quickstart (production only): https://vercel.com/docs/cron-jobs/quickstart
Cron jobs docs: https://vercel.com/docs/cron-jobs
UI + Map
shadcn/ui installation docs: https://ui.shadcn.com/docs/installation
shadcn manual install details: https://www.shadcn.io/ui/installation/manual
MapLibre HTML clusters example: https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/
Appendix A. UI/UX Implementation Kit (design tokens + components + layouts)
This appendix turns the UI/UX guidance into implementation-ready instructions, so an agent can produce a polished interface quickly without improvising. It is intentionally prescriptive.
A.1 Component library baseline
Adopt shadcn/ui as the core component source. Install via CLI or manual install depending on repo constraints.
A.1.1 CLI install (recommended)
# Create (if starting fresh)
pnpm dlx shadcn@latest create
# Add components iteratively
npx shadcn@latest add button
npx shadcn@latest add card
npx shadcn@latest add dialog
npx shadcn@latest add sheet
npx shadcn@latest add dropdown-menu
npx shadcn@latest add tabs
npx shadcn@latest add toast
A.1.2 Manual install (for existing custom setups)
pnpm add class-variance-authority clsx tailwind-merge lucide-react tw-animate-css
# Then create components.json and add components under components/ui/*
# Reference: https://www.shadcn.io/ui/installation/manual
A.2 Design tokens (CSS variables)
Use CSS variables for theme so future yearly themes can be swapped per event without code changes.
/* globals.css (excerpt) */
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;
  --radius: 12px;
}
.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --card: 222.2 84% 7.5%;
  --card-foreground: 210 40% 98%;
  --primary: 210 40% 98%;
  --primary-foreground: 222.2 47.4% 11.2%;
}
A.3 Screen-level wireframes (text)
A.3.1 Situation Room (public)
Top bar: Event selector (if logged in), Search (countries, people, posts), Right: Sign in / Profile, Bell icon (logged in).
Main canvas: Map (full height).
Right rail (desktop): Newsroom feed with filter chips: Breaking, Votes, Press Conf, All.
Bottom strip: Deadlines carousel (immutable), with 'Join Zoom' links when present.
Country click: opens Side Sheet with Country Card (delegates, stance, priorities, actions).
A.3.2 Workspace shell (private)
Left nav: Overview, Tasks, Meetings, Drafts, Votes, Chat, Files, Settings.
Main: module content.
Right rail: Context panel (team stance, quick actions, upcoming deadlines, unread).
Mobile: bottom nav (Map, Feed, Workspace, Chat, Votes).
A.4 UX details that materially reduce chaos during event week
Global Command Palette (Ctrl/Cmd+K): jump to country/team, start meeting request, create draft, open vote.
Pinned 'What should I do now?' widget: shows next deadline + assigned tasks + unread meeting requests.
One-click status macros for delegates: 'We support', 'We oppose', 'We propose amendment' (generates template text).
Offline-friendly: app shell cached; show 'Offline mode' badge; queue writes (chat drafts, notes) and flush on reconnect.
Appendix B. Realtime Authorization (Broadcast/Presence) with Supabase
If you use Broadcast/Presence channels, you should also enforce who can join and who can publish. Supabase supports channel authorization by adding RLS policies on realtime.messages; this controls broadcast and presence permissions.
Enable Realtime Authorization (public beta).
Disable 'Allow public access' in Realtime settings.
Write RLS policies for realtime.messages matching your room_id membership rules.
-- Example: allow broadcast on topic 'room:<room_id>' only for members of that room or event admins.
-- NOTE: adapt to your schema and test carefully.
alter table realtime.messages enable row level security;
create policy "realtime send allowed"
on realtime.messages for insert
to authenticated
with check (
  -- topic is like 'room:xxxxxxxx-xxxx-...'
  (
    split_part(topic, ':', 1) = 'room'
    and exists (
      select 1
      from public.chat_memberships cm
      join public.chat_rooms r on r.id = cm.room_id
      where cm.user_id = auth.uid()
        and cm.room_id = split_part(topic, ':', 2)::uuid
    )
  )
  or exists (
    select 1
    from public.chat_rooms r
    where r.id = split_part(topic, ':', 2)::uuid
      and public.is_event_admin(r.event_id)
  )
);
create policy "realtime receive allowed"
on realtime.messages for select
to authenticated
using (
  -- receiving follows same membership logic
  split_part(topic, ':', 1) = 'room'
  and exists (
    select 1
    from public.chat_memberships cm
    where cm.user_id = auth.uid()
      and cm.room_id = split_part(topic, ':', 2)::uuid
  )
  or exists (
    select 1
    from public.chat_rooms r
    where r.id = split_part(topic, ':', 2)::uuid
      and r.room_type = 'global'
      and exists (
        select 1 from public.event_memberships m
        where m.user_id = auth.uid() and m.event_id = r.event_id
      )
  )
);
Appendix C. Push Notifications Implementation (PWA + FCM + fallbacks)
This appendix gives an end-to-end path to implement push notifications without security shortcuts. FCM HTTP v1 requires OAuth2 tokens and must be invoked from a trusted server environment.
C.1 Recommended strategy
Implement in-app notifications first (always works).
Implement PWA installation flow and service worker.
Register push subscriptions (Web Push) for iOS/desktop web apps installed on Home Screen.
For Android, optionally use FCM Web Push if you already use Firebase; otherwise use standards-based Web Push provider.
Server sends push via FCM HTTP v1 (OAuth2 service account) or via a dedicated Web Push service.
C.2 Service worker skeleton (Web Push)
// public/sw.js (skeleton)
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'War Room';
  const options = {
    body: data.body,
    data: { url: data.url || '/' }
  };
  event.waitUntil(self.registration.showNotification(title, options));
});
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = event.notification.data?.url || '/';
  event.waitUntil(clients.openWindow(url));
});
C.3 Token + device registration flow
Client obtains a device token (FCM token or push subscription).
Client POSTs token to /api/notifications/register-device (server validates session, stores in user_device_tokens).
Server sends test push to confirm token validity; mark last_seen_at on success.
Provide UI toggles per notification type to prevent noise (Material guideline: avoid non-actionable notifications).
Appendix D. Cron Security and Idempotency
Vercel triggers cron jobs via HTTP GET to your production deployment, and it runs only in production deployments. Cron endpoints must be protected and idempotent: they can be retried or manually invoked.
D.1 Minimum hardening
Require an Authorization header with a shared secret (CRON_SECRET) to execute cron endpoints.
Optionally check User-Agent contains 'vercel-cron/1.0' (not sufficient alone; treat as a hint).
Make endpoints idempotent: multiple calls do not duplicate effects (use status checks and unique constraints).
// app/api/cron/close-expired-votes/route.ts (excerpt)
export async function GET(req: Request) {
  const secret = req.headers.get('authorization');
  if (secret !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 });
  }
  // Close votes where status='open' and close_at <= now(); update only rows still open.
  // Insert one audit_log row per vote close using ON CONFLICT DO NOTHING with a unique key.
  return new Response('ok');
}
Appendix E. Optional Modules Worth Adding (high impact, low complexity)
These are additions that improve coordination and perceived quality, without changing core architecture.
E.1 Meetings (request + agenda + outcome)
Meeting requests between teams/lobbies/journalists.
Agenda items + attachments.
Outcome notes and action items.
Visibility: private by default; shareable summary optional.
E.2 Files and media
Use Supabase Storage with per-event buckets or path prefixes.
RLS for storage objects aligned with event_id and team membership.
Virus scanning optional later; in v1, restrict file types and size.
E.3 Search and discovery
Search across: countries, people directory, news posts, votes, deadlines.
Server-side search (Postgres full text) to avoid leaking hidden rows client-side.